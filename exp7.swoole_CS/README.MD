## 异步和协程的区别


## 异步
对异步的理解
- 大白话：可以同时做很多的事情，无需等待某一个事情结束再去做另外一件事情。
- 专业话：进程在非阻塞模式下调用阻塞函数时不会一直处于阻塞状态，而是继续处理接下来的逻辑。

但是swoole对“异步”的封装，那真的是可以达到全异步。因为Swoole将所有的事件都注册到了EventLoop监听，
一旦某个事件被触发就会调用回调函数。


## 协程
什么是协程？
进程中的线程是怎么提高并发的呢？当一个进程获取到CPU时，在这个进程内在开启多个线程。这些线程可以同时去处理业务。
协程和线程类似，也是为了提高并发。

### 协程调度
这里将尽量通俗的讲述什么是协程调度，首先每个协程可以简单的理解为一个线程，大家知道多线程是为了提高程序的并发，同样的多协程也是为了提高并发。

用户的每个请求都会创建一个协程，请求结束后协程结束，如果同时有成千上万的并发请求，某一时刻某个进程内部会存在成千上万的协程，那么 CPU 资源是有限的，到底执行哪个协程的代码？

决定到底让 CPU 执行哪个协程的代码决断过程就是协程调度，Swoole 的调度策略又是怎么样的呢？

- 首先，在执行某个协程代码的过程中发现这行代码遇到了 Co::sleep() 或者产生了网络 IO，例如 MySQL->query()，这肯定是一个耗时的过程，Swoole 就会把这个 Mysql 连接的 Fd 放到 EventLoop 中。

    然后让出这个协程的 CPU 给其他协程使用：即 yield(挂起)
    等待 MySQL 数据返回后就继续执行这个协程：即 resume(恢复)
- 其次，如果协程的代码有 CPU 密集型代码，我们可以开启 enable_preemptive_scheduler，Swoole 会强行让这个协程让出 CPU

